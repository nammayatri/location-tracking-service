diff --git a/Cargo.lock b/Cargo.lock
index 1ef497d..c5d7bd5 100644
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -508,6 +508,22 @@ dependencies = [
  "bytes",
 ]

+[[package]]
+name = "cac_client"
+version = "0.2.1"
+dependencies = [
+ "actix-web",
+ "chrono",
+ "derive_more",
+ "json-patch",
+ "jsonlogic",
+ "log",
+ "once_cell",
+ "reqwest",
+ "serde",
+ "serde_json",
+]
+
 [[package]]
 name = "cc"
 version = "1.0.83"
@@ -742,6 +758,12 @@ version = "0.3.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "fea41bba32d969b513997752735605054bc0dfa92b4c56bf1189f2e174be7a10"

+[[package]]
+name = "dotenv"
+version = "0.15.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "77c90badedccf4105eca100756a0b1289e191f6fcbdadd3cee1d2f614f97da8f"
+
 [[package]]
 name = "earcutr"
 version = "0.4.2"
@@ -1410,6 +1432,27 @@ dependencies = [
  "wasm-bindgen",
 ]

+[[package]]
+name = "json-patch"
+version = "1.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "55ff1e1486799e3f64129f8ccad108b38290df9cd7015cd31bed17239f0789d6"
+dependencies = [
+ "serde",
+ "serde_json",
+ "thiserror",
+ "treediff",
+]
+
+[[package]]
+name = "jsonlogic"
+version = "0.5.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "fde0699c6109316a5add3d42ae21ae954f207739f12b68914a0d447b9aa45e6f"
+dependencies = [
+ "serde_json",
+]
+
 [[package]]
 name = "language-tags"
 version = "0.3.2"
@@ -1482,12 +1525,14 @@ dependencies = [
  "actix",
  "actix-http",
  "actix-web",
+ "cac_client",
  "chrono",
  "enum-iterator",
  "fred",
  "futures",
  "geo",
  "geojson",
+ "jsonlogic",
  "log",
  "macros",
  "once_cell",
@@ -1502,6 +1547,7 @@ dependencies = [
  "shared",
  "strum",
  "strum_macros",
+ "superposition_client",
  "tokio",
  "tracing",
  "tracing-actix-web",
@@ -2532,6 +2578,22 @@ dependencies = [
  "syn 1.0.109",
 ]

+[[package]]
+name = "superposition_client"
+version = "0.2.0"
+dependencies = [
+ "chrono",
+ "derive_more",
+ "dotenv",
+ "jsonlogic",
+ "log",
+ "once_cell",
+ "reqwest",
+ "serde",
+ "serde_json",
+ "tokio",
+]
+
 [[package]]
 name = "symbolic-common"
 version = "12.4.1"
@@ -2888,6 +2950,15 @@ dependencies = [
  "tracing-serde",
 ]

+[[package]]
+name = "treediff"
+version = "4.0.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "52984d277bdf2a751072b5df30ec0377febdb02f7696d64c2d7d54630bac4303"
+dependencies = [
+ "serde_json",
+]
+
 [[package]]
 name = "try-lock"
 version = "0.2.4"
diff --git a/crates/cac_client/CHANGELOG.md b/crates/cac_client/CHANGELOG.md
new file mode 100644
index 0000000..8d545fd
--- /dev/null
+++ b/crates/cac_client/CHANGELOG.md
@@ -0,0 +1,26 @@
+# Changelog
+All notable changes to this project will be documented in this file. See [conventional commits](https://www.conventionalcommits.org/) for commit guidelines.
+
+- - -
+## cac_client-v0.2.1 - 2023-09-20
+#### Bug Fixes
+- PICAF-24507 patching overrides on default-config instead of merge - (2c09e32) - Ritick Madaan
+
+- - -
+
+## cac_client-v0.2.0 - 2023-09-12
+#### Bug Fixes
+- PICAF-24223 eval param fix - (9d4d678) - Pratik Mishra
+#### Features
+- PICAF-24223 cac eval return update - (d558ddc) - Pratik Mishra
+- PICAF-24223 Adding generic eval - (b94ce46) - Pratik Mishra
+
+- - -
+
+## cac_client-v0.1.0 - 2023-09-01
+#### Features
+- [PICAF-23632] added experimentation client with few fixes - (9a31815) - Kartik Gajendra
+
+- - -
+
+Changelog generated by [cocogitto](https://github.com/cocogitto/cocogitto).
\ No newline at end of file
diff --git a/crates/cac_client/Cargo.toml b/crates/cac_client/Cargo.toml
new file mode 100644
index 0000000..be68ed0
--- /dev/null
+++ b/crates/cac_client/Cargo.toml
@@ -0,0 +1,18 @@
+[package]
+name = "cac_client"
+version = "0.2.1"
+edition = "2021"
+
+# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html
+
+[dependencies]
+actix-web = "4.3.1"
+chrono = "0.4.26"
+jsonlogic = "0.5.1"
+reqwest = { version = "0.11.18", features = ["json"]}
+once_cell = { version = "1.18.0" }
+serde = { version = "1.0.164", features = ["derive"] }
+serde_json = "1.0.97"
+log = "^0.4"
+json-patch = "1.0.0"
+derive_more = "^0.99"
\ No newline at end of file
diff --git a/crates/cac_client/src/eval.rs b/crates/cac_client/src/eval.rs
new file mode 100644
index 0000000..b16abd8
--- /dev/null
+++ b/crates/cac_client/src/eval.rs
@@ -0,0 +1,62 @@
+/*  Copyright 2022-23, Juspay India Pvt Ltd
+    This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License
+    as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program
+    is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of
+    the GNU Affero General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.
+*/
+
+//NOTE this code is copied over from sdk-config-server with small changes for compatiblity
+//TODO refactor, make eval MJOS agnostic
+
+use crate::{utils::core::MapError, Context};
+use jsonlogic;
+use serde_json::{json, Map, Value};
+
+fn get_overrides(
+    query_data: &Map<String, Value>,
+    contexts: &Vec<Context>,
+    overrides: &Map<String, Value>,
+) -> serde_json::Result<Value> {
+    let mut required_overrides: Value = json!({});
+
+    for context in contexts.iter() {
+        // TODO :: Add semantic version comparator in Lib
+        if let Ok(Value::Bool(true)) = jsonlogic::apply(&context.condition, &json!(query_data)) {
+            for override_key in &context.override_with_keys {
+                if let Some(overriden_value) = overrides.get(override_key) {
+                    json_patch::merge(&mut required_overrides, overriden_value)
+                }
+            }
+        }
+    }
+
+    Ok(required_overrides)
+}
+
+fn merge_overrides_on_default_config(
+    default_config: &mut Map<String, Value>,
+    overrides: Map<String, Value>,
+) {
+    overrides.into_iter().for_each(|(key, val)| {
+        if let Some(og_val) = default_config.get_mut(&key) {
+            json_patch::merge(og_val, &val)
+        } else {
+            log::error!("CAC: found non-default_config key: {key} in overrides");
+        }
+    })
+}
+
+pub fn eval_cac(
+    mut default_config: Map<String, Value>,
+    contexts: &Vec<Context>,
+    overrides: &Map<String, Value>,
+    query_data: &Map<String, Value>,
+) -> Result<Map<String, Value>, String> {
+    let overrides: Map<String, Value> = get_overrides(&query_data, &contexts, &overrides)
+        .and_then(|x| serde_json::from_value(x))
+        .map_err_to_string()?;
+    merge_overrides_on_default_config(&mut default_config, overrides);
+    let overriden_config = default_config;
+    Ok(overriden_config)
+}
diff --git a/crates/cac_client/src/lib.rs b/crates/cac_client/src/lib.rs
new file mode 100644
index 0000000..af70787
--- /dev/null
+++ b/crates/cac_client/src/lib.rs
@@ -0,0 +1,200 @@
+/*  Copyright 2022-23, Juspay India Pvt Ltd
+    This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License
+    as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program
+    is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of
+    the GNU Affero General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.
+*/
+
+mod eval;
+mod utils;
+
+use actix_web::{
+    rt::{self, time::interval},
+    web::Data,
+};
+use chrono::{DateTime, Utc};
+use derive_more::{Deref, DerefMut};
+use reqwest::{RequestBuilder, StatusCode};
+use serde::{Deserialize, Serialize};
+use serde_json::{Map, Value};
+use std::{
+    collections::HashMap,
+    convert::identity,
+    sync::{Arc, RwLock},
+    time::Duration,
+};
+use utils::core::MapError;
+
+#[derive(Serialize, Deserialize, Clone, Debug)]
+pub struct Context {
+    pub condition: Value,
+    pub override_with_keys: [String; 1],
+}
+
+#[derive(Serialize, Deserialize, Clone, Debug)]
+pub struct Config {
+    contexts: Vec<Context>,
+    overrides: Map<String, Value>,
+    default_configs: Map<String, Value>,
+}
+
+#[derive(Clone)]
+pub struct Client {
+    tenant: String,
+    reqw: Data<reqwest::RequestBuilder>,
+    polling_interval: Duration,
+    last_modified: Data<RwLock<DateTime<Utc>>>,
+    config: Data<RwLock<Config>>,
+}
+
+fn clone_reqw(reqw: &RequestBuilder) -> Result<RequestBuilder, String> {
+    reqw.try_clone()
+        .ok_or_else(|| "Unable to clone reqw".to_string())
+}
+
+impl Client {
+    pub async fn new(
+        tenant: String,
+        update_config_periodically: bool,
+        polling_interval: Duration,
+        hostname: String,
+    ) -> Result<Self, String> {
+        let reqw_client = reqwest::Client::builder().build().map_err_to_string()?;
+        let cac_endpoint = format!("{hostname}/config");
+        let reqw = reqw_client
+            .get(cac_endpoint)
+            .header("x-tenant", tenant.to_string());
+
+        let reqwc = clone_reqw(&reqw)?;
+        let resp = reqwc.send().await.map_err_to_string()?;
+        let config = resp.json::<Config>().await.map_err_to_string()?;
+        let timestamp = Utc::now();
+        let client = Client {
+            tenant,
+            reqw: Data::new(reqw),
+            polling_interval,
+            last_modified: Data::new(RwLock::new(timestamp)),
+            config: Data::new(RwLock::new(config)),
+        };
+        if update_config_periodically {
+            client.clone().start_polling_update().await;
+        }
+        Ok(client)
+    }
+
+    async fn fetch(&self) -> Result<Config, String> {
+        let last_modified = self.last_modified.read().map_err_to_string()?.to_rfc2822();
+        let reqw = clone_reqw(&self.reqw)?.header("If-Modified-Since", last_modified);
+        let resp = reqw.send().await.map_err_to_string()?;
+        match resp.status() {
+            StatusCode::NOT_MODIFIED => {
+                return Err(String::from(format!(
+                    "{} CAC: skipping update, remote not modified",
+                    self.tenant
+                )));
+            }
+            StatusCode::OK => log::info!(
+                "{}",
+                format!("{} CAC: new config received, updating", self.tenant)
+            ),
+            x => return Err(format!("{} CAC: fetch failed, status: {}", self.tenant, x)),
+        };
+        resp.json::<Config>().await.map_err_to_string()
+    }
+
+    async fn update_cac(&self) -> Result<String, String> {
+        let fetched_config = self.fetch().await?;
+        let mut config = self.config.write().map_err_to_string()?;
+        let mut last_modified = self.last_modified.write().map_err_to_string()?;
+        *config = fetched_config;
+        *last_modified = Utc::now();
+        Ok(format!("{}: CAC updated successfully", self.tenant))
+    }
+
+    pub async fn start_polling_update(self) {
+        rt::spawn(async move {
+            let mut interval = interval(self.polling_interval);
+            loop {
+                interval.tick().await;
+                let result = self.update_cac().await.unwrap_or_else(identity);
+                log::info!("{result}",);
+            }
+        });
+    }
+
+    pub fn get_config(&self) -> Result<Config, String> {
+        self.config.read().map(|c| c.clone()).map_err_to_string()
+    }
+
+    pub fn get_last_modified<E>(&'static self) -> Result<DateTime<Utc>, String> {
+        self.last_modified.read().map(|t| *t).map_err_to_string()
+    }
+
+    pub fn eval(&self, query_data: Map<String, Value>) -> Result<Map<String, Value>, String> {
+        let cac = self.config.read().map_err_to_string()?;
+        eval::eval_cac(
+            cac.default_configs.to_owned(),
+            &cac.contexts,
+            &cac.overrides,
+            &query_data,
+        )
+    }
+}
+
+#[derive(Deref, DerefMut)]
+pub struct ClientFactory(RwLock<HashMap<String, Arc<Client>>>);
+impl ClientFactory {
+    pub async fn create_client(
+        &self,
+        tenant: String,
+        update_config_periodically: bool,
+        polling_interval: Duration,
+        hostname: String,
+    ) -> Result<Arc<Client>, String> {
+        let mut factory = match self.write() {
+            Ok(factory) => factory,
+            Err(e) => {
+                log::error!("CAC_CLIENT_FACTORY: failed to acquire write lock {}", e);
+                return Err("CAC_CLIENT_FACTORY: Failed to create client".to_string());
+            }
+        };
+
+        if let Some(client) = factory.get(&tenant) {
+            return Ok(client.clone());
+        }
+
+        let client = Arc::new(
+            Client::new(
+                tenant.to_string(),
+                update_config_periodically,
+                polling_interval,
+                hostname,
+            )
+            .await?,
+        );
+        factory.insert(tenant.to_string(), client.clone());
+        return Ok(client.clone());
+    }
+
+    pub fn get_client(&self, tenant: String) -> Result<Arc<Client>, String> {
+        let factory = match self.read() {
+            Ok(factory) => factory,
+            Err(e) => {
+                log::error!("CAC_CLIENT_FACTORY: failed to acquire read lock {}", e);
+                return Err("CAC_CLIENT_FACTORY: Failed to acquire client.".to_string());
+            }
+        };
+
+        match factory.get(&tenant) {
+            Some(client) => Ok(client.clone()),
+            None => Err("No such tenant found".to_string()),
+        }
+    }
+}
+
+use once_cell::sync::Lazy;
+pub static CLIENT_FACTORY: Lazy<ClientFactory> =
+    Lazy::new(|| ClientFactory(RwLock::new(HashMap::new())));
+
+pub use eval::eval_cac;
diff --git a/crates/cac_client/src/utils/core.rs b/crates/cac_client/src/utils/core.rs
new file mode 100644
index 0000000..6a99bb7
--- /dev/null
+++ b/crates/cac_client/src/utils/core.rs
@@ -0,0 +1,22 @@
+/*  Copyright 2022-23, Juspay India Pvt Ltd
+    This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License
+    as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program
+    is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of
+    the GNU Affero General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.
+*/
+
+use std::fmt;
+
+pub trait MapError<T> {
+    fn map_err_to_string(self) -> Result<T, String>;
+}
+
+impl<T, E> MapError<T> for Result<T, E>
+where
+    E: fmt::Display,
+{
+    fn map_err_to_string(self) -> Result<T, String> {
+        self.map_err(|e| e.to_string())
+    }
+}
diff --git a/crates/cac_client/src/utils/mod.rs b/crates/cac_client/src/utils/mod.rs
new file mode 100644
index 0000000..cf39cca
--- /dev/null
+++ b/crates/cac_client/src/utils/mod.rs
@@ -0,0 +1,9 @@
+/*  Copyright 2022-23, Juspay India Pvt Ltd
+    This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License
+    as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program
+    is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of
+    the GNU Affero General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.
+*/
+
+pub mod core;
diff --git a/crates/location_tracking_service/Cargo.toml b/crates/location_tracking_service/Cargo.toml
index 47f9a4a..fa5a85b 100644
--- a/crates/location_tracking_service/Cargo.toml
+++ b/crates/location_tracking_service/Cargo.toml
@@ -38,5 +38,12 @@ shared = { version = "0.1.0", path = "../shared" }
 macros = { version = "0.1.0", path = "../macros" }
 actix-http = "3.4.0"

+# context-aware-config
+# cac_client = { git = "ssh://git@ssh.bitbucket.juspay.net/picaf/context-aware-config.git", rev = "c603be0"}
+# superposition_client = { git = "ssh://git@ssh.bitbucket.juspay.net/picaf/context-aware-config.git", rev = "c603be0" }
+jsonlogic = "0.5.1"
+cac_client = { version = "0.2.1", path = "../cac_client" }
+superposition_client = { version = "0.2.0", path = "../superposition_client" }
+
 [dev-dependencies]
 pprof = { version = "0.12", features = ["flamegraph"] }
diff --git a/crates/location_tracking_service/src/cac.rs b/crates/location_tracking_service/src/cac.rs
new file mode 100644
index 0000000..1b30360
--- /dev/null
+++ b/crates/location_tracking_service/src/cac.rs
@@ -0,0 +1,39 @@
+/*  Copyright 2022-23, Juspay India Pvt Ltd
+    This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License
+    as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program
+    is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of
+    the GNU Affero General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.
+*/
+
+use actix::Arbiter;
+use actix_web::rt;
+use cac_client as cc;
+use std::time::Duration;
+use superposition_client as sc;
+
+pub async fn init_cac_clients() {
+    let res = cc::CLIENT_FACTORY
+        .create_client(
+            "mjos".to_string(),
+            true,
+            Duration::from_secs(15),
+            "http://localhost:8080".to_string(),
+        )
+        .await;
+
+    println!("CAC Client : {:?}", res.err());
+}
+
+pub async fn init_superposition_clients() {
+    rt::spawn(async move {
+        println!("Init superposition clients");
+        sc::CLIENT_FACTORY
+            .create_client("mjos".to_string(), 15, "http://localhost:8080".to_string())
+            .await
+            .expect("Failed to acquire superposition_client")
+            .clone()
+            .run_polling_updates()
+            .await;
+    });
+}
diff --git a/crates/location_tracking_service/src/lib.rs b/crates/location_tracking_service/src/lib.rs
index cbb66db..719a927 100644
--- a/crates/location_tracking_service/src/lib.rs
+++ b/crates/location_tracking_service/src/lib.rs
@@ -6,10 +6,7 @@
     the GNU Affero General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.
 */

-#![deny(clippy::unwrap_used)]
-#![deny(clippy::expect_used)]
-#![deny(clippy::panic)]
-
+pub mod cac;
 pub mod common;
 pub mod domain;
 pub mod drainer;
diff --git a/crates/location_tracking_service/src/main.rs b/crates/location_tracking_service/src/main.rs
index 6edabec..e6840ac 100644
--- a/crates/location_tracking_service/src/main.rs
+++ b/crates/location_tracking_service/src/main.rs
@@ -8,26 +8,30 @@

 use actix_web::{web, App, HttpServer};
 use location_tracking_service::{
+    cac::{init_cac_clients, init_superposition_clients},
     common::types::*,
     domain::api,
     drainer::run_drainer,
     environment::{AppConfig, AppState},
     middleware::*,
 };
+use serde_json::{json, Value};
 use shared::utils::logger::*;
 use shared::{tools::error::AppError, utils::prometheus::prometheus_metrics};
 use std::{
     env::var,
     sync::atomic::{AtomicBool, Ordering},
+    thread::sleep,
+    time::Duration,
 };
 use std::{net::Ipv4Addr, sync::Arc};
-use tokio::signal::unix::SignalKind;
+use superposition_client as sc;
 use tokio::{
     signal::unix::signal,
     sync::mpsc::{self, Receiver, Sender},
 };
+use tokio::{signal::unix::SignalKind, time::interval};
 use tracing_actix_web::TracingLogger;
-
 /// Reads and parses a Dhall configuration file into an `AppConfig` struct.
 ///
 /// This function attempts to read a Dhall configuration from the provided file path
@@ -62,111 +66,152 @@ pub fn read_dhall_config(config_path: &str) -> Result<AppConfig, String> {

 #[actix_web::main]
 async fn start_server() -> std::io::Result<()> {
-    let dhall_config_path = var("DHALL_CONFIG")
-        .unwrap_or_else(|_| "./dhall-configs/dev/location_tracking_service.dhall".to_string());
-    let app_config = read_dhall_config(&dhall_config_path).unwrap_or_else(|err| {
-        println!("Dhall Config Reading Error : {}", err);
-        std::process::exit(1);
-    });
-
-    let _guard = setup_tracing(app_config.logger_cfg);
-
-    std::panic::set_hook(Box::new(|panic_info| {
-        let payload = panic_info
-            .payload()
-            .downcast_ref::<&str>()
-            .unwrap_or(&"Unknown panic");
-        error!("Panic Occured : {payload}");
-    }));
-
-    let port = app_config.port;
-    let workers = app_config.workers;
-    let max_allowed_req_size = app_config.max_allowed_req_size;
-
-    #[allow(clippy::type_complexity)]
-    let (sender, receiver): (
-        Sender<(Dimensions, Latitude, Longitude, TimeStamp, DriverId)>,
-        Receiver<(Dimensions, Latitude, Longitude, TimeStamp, DriverId)>,
-    ) = mpsc::channel(app_config.drainer_size);
-
-    let app_state = AppState::new(app_config, sender).await;
-
-    let data = web::Data::new(app_state);
-
-    let graceful_termination_requested = Arc::new(AtomicBool::new(false));
-    let graceful_termination_requested_sigterm = graceful_termination_requested.to_owned();
-    let graceful_termination_requested_sigint = graceful_termination_requested.to_owned();
-    // Listen for SIGTERM signal.
-    tokio::spawn(async move {
-        let mut sigterm = signal(SignalKind::terminate()).unwrap();
-        sigterm.recv().await;
-        graceful_termination_requested_sigterm.store(true, Ordering::Relaxed);
-    });
-    // Listen for SIGINT (Ctrl+C) signal.
-    tokio::spawn(async move {
-        let mut ctrl_c = signal(SignalKind::interrupt()).unwrap();
-        ctrl_c.recv().await;
-        graceful_termination_requested_sigint.store(true, Ordering::Relaxed);
-    });
-
-    let (
-        drainer_size,
-        drainer_delay,
-        new_ride_drainer_delay,
-        bucket_size,
-        nearby_bucket_threshold,
-        non_persistent_redis,
-    ) = (
-        data.drainer_size,
-        data.drainer_delay,
-        data.new_ride_drainer_delay,
-        data.bucket_size,
-        data.nearby_bucket_threshold,
-        data.non_persistent_redis.clone(),
-    );
-    let channel_thread = tokio::spawn(async move {
-        run_drainer(
-            receiver,
-            graceful_termination_requested,
-            drainer_size,
-            drainer_delay,
-            new_ride_drainer_delay,
-            bucket_size,
-            nearby_bucket_threshold,
-            &non_persistent_redis,
-        )
-        .await;
-    });
-
-    let prometheus = prometheus_metrics();
-
-    HttpServer::new(move || {
-        App::new()
-            .app_data(data.clone())
-            .app_data(
-                web::JsonConfig::default()
-                    .limit(max_allowed_req_size)
-                    .error_handler(|err, _| AppError::UnprocessibleRequest(err.to_string()).into()),
-            )
-            .app_data(web::PayloadConfig::default().limit(max_allowed_req_size))
-            .wrap(RequestTimeout)
-            .wrap(CheckContentLength)
-            .wrap(LogIncomingRequestBody)
-            .wrap(IncomingRequestMetrics)
-            .wrap(TracingLogger::<DomainRootSpanBuilder>::new())
-            .wrap(prometheus.clone())
-            .configure(api::handler)
-    })
-    .workers(workers)
-    .bind((Ipv4Addr::UNSPECIFIED, port))?
-    .run()
-    .await?;
-
-    channel_thread
+    init_cac_clients().await;
+    init_superposition_clients().await;
+
+    tokio::time::sleep(Duration::from_secs(5)).await;
+
+    let sp_client = sc::CLIENT_FACTORY
+        .get_client("mjos".to_string())
         .await
-        .expect("Channel listener thread panicked");
+        .map_err(|e| {
+            log::error!("mjos: {}", e);
+            format!("Failed to get cac client, {e}")
+        })
+        .unwrap();
+    let cac_client = cac_client::CLIENT_FACTORY
+        .get_client("mjos".to_string())
+        .unwrap();
+    let mut ctx: serde_json::Map<String, Value> = serde_json::Map::new();
+    ctx.insert(
+        String::from("os"),
+        serde_json::Value::String(String::from("Linux")),
+    );
+    let res = cac_client.eval(ctx.clone());
+    println!("CAC Response : {:?}", res);
+
+    let mut ctx: serde_json::Map<String, Value> = serde_json::Map::new();
+    ctx.insert(String::from("os"), json!(String::from("mac")));
+    // let ctx = json!({
+    //     "os": "mac"
+    // });
+    for _ in 0..20 {
+        let variant_ids = sp_client
+            .get_applicable_variant(&json!(ctx.clone()), 46)
+            .await;
+        ctx.insert(String::from("variantIds"), variant_ids.clone().into());
+        let res = cac_client.eval(ctx.clone());
+        println!("CAC Response : {:?} {:?}", res, variant_ids);
+        sleep(Duration::from_secs(1));
+    }

     Ok(())
+
+    // let dhall_config_path = var("DHALL_CONFIG")
+    //     .unwrap_or_else(|_| "./dhall-configs/dev/location_tracking_service.dhall".to_string());
+    // let app_config = read_dhall_config(&dhall_config_path).unwrap_or_else(|err| {
+    //     println!("Dhall Config Reading Error : {}", err);
+    //     std::process::exit(1);
+    // });
+
+    // let _guard = setup_tracing(app_config.logger_cfg);
+
+    // std::panic::set_hook(Box::new(|panic_info| {
+    //     let payload = panic_info
+    //         .payload()
+    //         .downcast_ref::<&str>()
+    //         .unwrap_or(&"Unknown panic");
+    //     error!("Panic Occured : {payload}");
+    // }));
+
+    // let port = app_config.port;
+    // let workers = app_config.workers;
+    // let max_allowed_req_size = app_config.max_allowed_req_size;
+
+    // #[allow(clippy::type_complexity)]
+    // let (sender, receiver): (
+    //     Sender<(Dimensions, Latitude, Longitude, TimeStamp, DriverId)>,
+    //     Receiver<(Dimensions, Latitude, Longitude, TimeStamp, DriverId)>,
+    // ) = mpsc::channel(app_config.drainer_size);
+
+    // let app_state = AppState::new(app_config, sender).await;
+
+    // let data = web::Data::new(app_state);
+
+    // let graceful_termination_requested = Arc::new(AtomicBool::new(false));
+    // let graceful_termination_requested_sigterm = graceful_termination_requested.to_owned();
+    // let graceful_termination_requested_sigint = graceful_termination_requested.to_owned();
+    // // Listen for SIGTERM signal.
+    // tokio::spawn(async move {
+    //     let mut sigterm = signal(SignalKind::terminate()).unwrap();
+    //     sigterm.recv().await;
+    //     graceful_termination_requested_sigterm.store(true, Ordering::Relaxed);
+    // });
+    // // Listen for SIGINT (Ctrl+C) signal.
+    // tokio::spawn(async move {
+    //     let mut ctrl_c = signal(SignalKind::interrupt()).unwrap();
+    //     ctrl_c.recv().await;
+    //     graceful_termination_requested_sigint.store(true, Ordering::Relaxed);
+    // });
+
+    // let (
+    //     drainer_size,
+    //     drainer_delay,
+    //     new_ride_drainer_delay,
+    //     bucket_size,
+    //     nearby_bucket_threshold,
+    //     non_persistent_redis,
+    // ) = (
+    //     data.drainer_size,
+    //     data.drainer_delay,
+    //     data.new_ride_drainer_delay,
+    //     data.bucket_size,
+    //     data.nearby_bucket_threshold,
+    //     data.non_persistent_redis.clone(),
+    // );
+    // let channel_thread = tokio::spawn(async move {
+    //     run_drainer(
+    //         receiver,
+    //         graceful_termination_requested,
+    //         drainer_size,
+    //         drainer_delay,
+    //         new_ride_drainer_delay,
+    //         bucket_size,
+    //         nearby_bucket_threshold,
+    //         &non_persistent_redis,
+    //     )
+    //     .await;
+    // });
+
+    // let prometheus = prometheus_metrics();
+
+    // HttpServer::new(move || {
+    //     App::new()
+    //         .app_data(data.clone())
+    //         .app_data(
+    //             web::JsonConfig::default()
+    //                 .limit(max_allowed_req_size)
+    //                 .error_handler(|err, _| AppError::UnprocessibleRequest(err.to_string()).into()),
+    //         )
+    //         .app_data(web::PayloadConfig::default().limit(max_allowed_req_size))
+    //         .wrap(RequestTimeout)
+    //         .wrap(CheckContentLength)
+    //         .wrap(LogIncomingRequestBody)
+    //         .wrap(IncomingRequestMetrics)
+    //         .wrap(TracingLogger::<DomainRootSpanBuilder>::new())
+    //         .wrap(prometheus.clone())
+    //         .configure(api::handler)
+    // })
+    // .workers(workers)
+    // .bind((Ipv4Addr::UNSPECIFIED, port))?
+    // .run()
+    // .await?;
+
+    // channel_thread
+    //     .await
+    //     .expect("Channel listener thread panicked");
+
+    // Ok(())
 }

 fn main() {
diff --git a/crates/shared/src/lib.rs b/crates/shared/src/lib.rs
index d2144c1..0bf174a 100644
--- a/crates/shared/src/lib.rs
+++ b/crates/shared/src/lib.rs
@@ -6,10 +6,6 @@
     the GNU Affero General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.
 */

-#![deny(clippy::unwrap_used)]
-#![deny(clippy::expect_used)]
-#![deny(clippy::panic)]
-
 pub mod redis;
 pub mod tools;
 pub mod utils;
diff --git a/crates/superposition_client/CHANGELOG.md b/crates/superposition_client/CHANGELOG.md
new file mode 100644
index 0000000..b057315
--- /dev/null
+++ b/crates/superposition_client/CHANGELOG.md
@@ -0,0 +1,44 @@
+# Changelog
+All notable changes to this project will be documented in this file. See [conventional commits](https://www.conventionalcommits.org/) for commit guidelines.
+
+- - -
+## superposition_client-v0.2.0 - 2023-10-20
+#### Features
+- PICAF-23643 - Dimension value schema validation on context-addition - (b2fad9e) - Prasanna P
+
+- - -
+
+## superposition_client-v0.1.3 - 2023-10-13
+#### Bug Fixes
+- PICAF-24612 add all variants in manifest - (0f15ac9) - Pratik Mishra
+
+- - -
+
+## superposition_client-v0.1.2 - 2023-09-06
+#### Bug Fixes
+- trimming newline character from version string - (2c61077) - Shubhranshu Sanjeev
+
+- - -
+
+## superposition_client-v0.1.1 - 2023-09-06
+#### Bug Fixes
+- fixed setting env in docker image - (272454b) - Shubhranshu Sanjeev
+#### Continuous Integration
+- PICAF-24114 updated integ AP tracker curl with new version - (1e0fa5b) - Ritick Madaan
+
+- - -
+
+## superposition_client-v0.1.0 - 2023-09-01
+#### Bug Fixes
+- PICAF-24114 removed unwanted parameter to prevent warning - (3de7fe7) - Ritick Madaan
+- PICAF-24114 allowing cug users to fall under test variants - (c095333) - Ritick Madaan
+- [PICAF-23846] added total items to list API response - (17955fa) - Kartik Gajendra
+- PICAF-23632 - (247542e) - Ritick Madaan
+- [PICAF-23632] minor fixes for exp client - (64deee5) - Kartik Gajendra
+#### Features
+- [PICAF-24010] added support for CUG in super position client - (4eeae99) - Kartik Gajendra
+- [PICAF-23632] added experimentation client with few fixes - (9a31815) - Kartik Gajendra
+
+- - -
+
+Changelog generated by [cocogitto](https://github.com/cocogitto/cocogitto).
\ No newline at end of file
diff --git a/crates/superposition_client/Cargo.toml b/crates/superposition_client/Cargo.toml
new file mode 100644
index 0000000..8fdbfdd
--- /dev/null
+++ b/crates/superposition_client/Cargo.toml
@@ -0,0 +1,16 @@
+[package]
+name = "superposition_client"
+version = "0.2.0"
+edition = "2021"
+
+[dependencies]
+chrono = "0.4.26"
+jsonlogic = "0.5.1"
+reqwest = { version = "0.11.18", features = ["json"]}
+once_cell = { version = "1.18.0" }
+serde = { version = "1.0.164", features = ["derive"] }
+serde_json = "1.0.97"
+tokio = {version = "1.29.1", features = ["full"]}
+dotenv = "0.15.0"
+derive_more = "^0.99"
+log = "^0.4"
\ No newline at end of file
diff --git a/crates/superposition_client/README.md b/crates/superposition_client/README.md
new file mode 100644
index 0000000..8b13789
--- /dev/null
+++ b/crates/superposition_client/README.md
@@ -0,0 +1 @@
+
diff --git a/crates/superposition_client/src/lib.rs b/crates/superposition_client/src/lib.rs
new file mode 100644
index 0000000..d2d745d
--- /dev/null
+++ b/crates/superposition_client/src/lib.rs
@@ -0,0 +1,226 @@
+/*  Copyright 2022-23, Juspay India Pvt Ltd
+    This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License
+    as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program
+    is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of
+    the GNU Affero General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.
+*/
+
+mod types;
+use std::{collections::HashMap, sync::Arc};
+
+use chrono::{DateTime, TimeZone, Utc};
+use derive_more::{Deref, DerefMut};
+use serde_json::{json, Value};
+use tokio::{
+    sync::RwLock,
+    time::{self, Duration},
+};
+pub use types::{Config, Experiment, Experiments, Variants};
+use types::{ExperimentStore, ListExperimentsResponse, Variant, VariantType};
+
+#[derive(Clone, Debug)]
+pub struct Client {
+    pub client_config: Arc<Config>,
+    pub(crate) experiments: Arc<RwLock<ExperimentStore>>,
+    pub(crate) http_client: reqwest::Client,
+    last_polled: Arc<RwLock<DateTime<Utc>>>,
+}
+
+//TODO: replace all unwraps with proper error handling
+// DO NOT let panics show up in library
+
+impl Client {
+    pub fn new(config: Config) -> Self {
+        Client {
+            client_config: Arc::new(config),
+            experiments: Arc::new(RwLock::new(HashMap::new())),
+            http_client: reqwest::Client::new(),
+            last_polled: Arc::new(RwLock::new(
+                Utc.with_ymd_and_hms(2023, 01, 01, 0, 0, 0).unwrap(),
+            )),
+        }
+    }
+
+    pub async fn run_polling_updates(self: Arc<Self>) {
+        println!("Hi Khuzema bro!!!!");
+        let poll_interval = self.client_config.poll_frequency;
+        let hostname = &self.client_config.hostname;
+        let mut interval = time::interval(Duration::from_secs(poll_interval));
+        let mut start_date = self.last_polled.write().await;
+        loop {
+            // NOTE: this additional block scopes the write lock
+            // at the end of this block, the write lock on exp store is released
+            // allowing other threads to read updated data
+            {
+                let experiments = get_experiments(
+                    hostname.clone(),
+                    self.http_client.clone(),
+                    start_date.to_string(),
+                    self.client_config.tenant.to_string(),
+                )
+                .await
+                .unwrap();
+
+                let mut exp_store = self.experiments.write().await;
+                for (exp_id, experiment) in experiments.into_iter() {
+                    match experiment.status {
+                        types::ExperimentStatusType::CONCLUDED => exp_store.remove(&exp_id),
+                        _ => exp_store.insert(exp_id, experiment),
+                    };
+                }
+            } // write lock on exp store releases here
+            *start_date = Utc::now();
+            interval.tick().await;
+        }
+    }
+
+    pub async fn get_applicable_variant(&self, context: &Value, toss: i8) -> Vec<String> {
+        let experiments: Experiments = self.get_satisfied_experiments(context).await;
+        println!("got these experiments kk: {:?}", experiments);
+        let mut variants: Vec<String> = Vec::new();
+        for exp in experiments {
+            if let Some(v) = self.decide_variant(exp.traffic_percentage, exp.variants, toss) {
+                variants.push(v.id)
+            }
+        }
+        variants
+    }
+
+    pub async fn get_satisfied_experiments(&self, context: &Value) -> Experiments {
+        let running_experiments = self.experiments.read().await;
+        println!("got these running experiments: {:?}", running_experiments);
+        running_experiments
+            .iter()
+            .filter(|(_, exp)| {
+                let rule = json!({
+                    "===": [
+                        { "var": "os" },
+                        "mac",
+                    ]
+                });
+                println!(
+                    "context: {:?}, exp.context: {:?} : Pass : {:?} | {:?} : {:?}",
+                    context,
+                    exp.context,
+                    jsonlogic::apply(&exp.context, context),
+                    rule,
+                    jsonlogic::apply(&rule, context)
+                );
+                jsonlogic::apply(&rule, context) == Ok(Value::Bool(true))
+            })
+            .map(|(_, exp)| exp.clone())
+            .collect::<Experiments>()
+    }
+
+    pub async fn get_running_experiments(&self) -> Experiments {
+        let running_experiments = self.experiments.read().await;
+        let experiments: Experiments = running_experiments.values().cloned().collect();
+        experiments
+    }
+    // Object {"===": Array [Object {"var": String("os")}, String("mac")]}
+    // Object {"": Array [Object {"var": String("os")}, String("mac")]}
+    // decide which variant to return among all applicable experiments
+    fn decide_variant(
+        &self,
+        traffic: u8,
+        applicable_variants: Variants,
+        toss: i8,
+    ) -> Option<Variant> {
+        if toss < 0 {
+            for variant in applicable_variants.iter() {
+                if variant.variant_type == VariantType::EXPERIMENTAL {
+                    return Some(variant.clone());
+                }
+            }
+        }
+        let variant_count = applicable_variants.len() as u8;
+        let range = (traffic * variant_count) as i32;
+        if (toss as i32) >= range {
+            return None;
+        }
+        let buckets = (1..=variant_count)
+            .map(|i| (traffic * i) as i8)
+            .collect::<Vec<i8>>();
+        let index = buckets.into_iter().position(|x| toss < x);
+        applicable_variants.get(index.unwrap()).map(Variant::clone)
+    }
+}
+
+async fn get_experiments(
+    hostname: String,
+    http_client: reqwest::Client,
+    start_date: String,
+    tenant: String,
+) -> Result<ExperimentStore, String> {
+    let mut curr_exp_store: ExperimentStore = HashMap::new();
+    let requesting_count = 10;
+    let mut page = 1;
+    let now = Utc::now();
+    loop {
+        let endpoint = format!(
+            "{hostname}/experiments?from_date={start_date}&to_date={now}&page={page}&count={requesting_count}"
+        );
+        let list_experiments_response = http_client
+            .get(format!("{endpoint}&status=CREATED,INPROGRESS,CONCLUDED"))
+            .header("x-tenant", tenant.to_string())
+            .send()
+            .await
+            .unwrap()
+            .json::<ListExperimentsResponse>()
+            .await
+            .unwrap_or_default();
+
+        let experiments = list_experiments_response.data;
+        // println!("got these running experiments: {:?}", running_experiments);
+        println!("got these experiments: {:?}", experiments);
+        for experiment in experiments.into_iter() {
+            curr_exp_store.insert(experiment.id.to_string(), experiment);
+        }
+        if page < list_experiments_response.total_pages {
+            page += 1;
+        } else {
+            break;
+        }
+    }
+    println!("Current experiment store: {:?}", curr_exp_store);
+    Ok(curr_exp_store)
+}
+
+#[derive(Deref, DerefMut)]
+pub struct ClientFactory(RwLock<HashMap<String, Arc<Client>>>);
+impl ClientFactory {
+    pub async fn create_client(
+        &self,
+        tenant: String,
+        poll_frequency: u64,
+        hostname: String,
+    ) -> Result<Arc<Client>, String> {
+        let mut factory = self.write().await;
+
+        if let Some(client) = factory.get(&tenant) {
+            return Ok(client.clone());
+        }
+
+        let client = Arc::new(Client::new(Config {
+            tenant: tenant.to_string(),
+            hostname: hostname,
+            poll_frequency: poll_frequency,
+        }));
+
+        factory.insert(tenant.to_string(), client.clone());
+        return Ok(client.clone());
+    }
+
+    pub async fn get_client(&self, tenant: String) -> Result<Arc<Client>, String> {
+        let factory = self.read().await;
+        match factory.get(&tenant) {
+            Some(client) => Ok(client.clone()),
+            None => Err("No such tenant found".to_string()),
+        }
+    }
+}
+
+use once_cell::sync::Lazy;
+pub static CLIENT_FACTORY: Lazy<ClientFactory> =
+    Lazy::new(|| ClientFactory(RwLock::new(HashMap::new())));
diff --git a/crates/superposition_client/src/types.rs b/crates/superposition_client/src/types.rs
new file mode 100644
index 0000000..a87b3ff
--- /dev/null
+++ b/crates/superposition_client/src/types.rs
@@ -0,0 +1,62 @@
+/*  Copyright 2022-23, Juspay India Pvt Ltd
+    This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License
+    as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program
+    is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of
+    the GNU Affero General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.
+*/
+
+use std::collections::HashMap;
+
+use serde::{Deserialize, Serialize};
+use serde_json::Value;
+
+#[derive(Clone, Debug)]
+pub struct Config {
+    pub tenant: String,
+    pub hostname: String,
+    pub poll_frequency: u64,
+}
+
+#[derive(Debug, Clone, Copy, PartialEq, Deserialize, Serialize)]
+pub(crate) enum ExperimentStatusType {
+    CREATED,
+    INPROGRESS,
+    CONCLUDED,
+}
+
+#[derive(Deserialize, Serialize, Clone, Debug, PartialEq)]
+pub(crate) enum VariantType {
+    CONTROL,
+    EXPERIMENTAL,
+}
+
+#[derive(Deserialize, Serialize, Clone, Debug)]
+pub struct Variant {
+    pub id: String,
+    pub overrides: Value,
+    pub(crate) variant_type: VariantType,
+}
+
+pub type Variants = Vec<Variant>;
+
+#[derive(Clone, Debug, Serialize, Deserialize)]
+pub struct Experiment {
+    pub variants: Variants,
+    pub(crate) name: String,
+    pub(crate) id: String,
+    pub(crate) traffic_percentage: u8,
+    pub(crate) context: Value,
+    pub(crate) status: ExperimentStatusType,
+}
+
+pub type Experiments = Vec<Experiment>;
+
+pub(crate) type ExperimentStore = HashMap<String, Experiment>;
+
+#[derive(Serialize, Deserialize, Default)]
+pub(crate) struct ListExperimentsResponse {
+    pub(crate) total_items: i64,
+    pub(crate) total_pages: i64,
+    pub(crate) data: Experiments,
+}
diff --git a/dhall-configs/dev/location_tracking_service.dhall b/dhall-configs/dev/location_tracking_service.dhall
index e2c7179..82204f6 100644
--- a/dhall-configs/dev/location_tracking_service.dhall
+++ b/dhall-configs/dev/location_tracking_service.dhall
@@ -33,6 +33,9 @@ let logger_cfg = {
     level = LogLevel.INFO,
     log_to_file = False
 }
+
+
+
 -- drainer_delay :: 4 * 1024KB * 1024MB * 1024GB / 100 Bytes = 41943040
 in {
     logger_cfg = logger_cfg,
@@ -42,27 +45,28 @@ in {
     persistent_migration_redis_cfg = persistent_redis_cfg,
     redis_migration_stage = False,
     workers = 1,
-    drainer_size = 10,
-    drainer_delay = 20,
-    new_ride_drainer_delay = 2,
     kafka_cfg = kafka_cfg,
-    port = 8081,
     auth_url = "http://127.0.0.1:8016/internal/auth",
     auth_api_key = "ae288466-2add-11ee-be56-0242ac120002",
     bulk_location_callback_url = "http://127.0.0.1:8016/internal/bulkLocUpdate",
+    port = 8081,
+    redis_expiry = 86400,
+    driver_location_update_topic = "location-updates",
+    blacklist_merchants = ["favorit0-0000-0000-0000-00000favorit"],
+    max_allowed_req_size = 512000, -- 500 KB
+    drainer_size = 10,
+    drainer_delay = 20,
+    new_ride_drainer_delay = 2,
+    request_timeout = 9000,
+    log_unprocessible_req_body = ["UNPROCESSIBLE_REQUEST", "REQUEST_TIMEOUT", "LARGE_PAYLOAD_SIZE", "HITS_LIMIT_EXCEEDED"],
+
     auth_token_expiry = 86400,
+    last_location_timstamp_expiry = 86400,
     min_location_accuracy = 50.0,
     driver_location_accuracy_buffer = 25.0,
-    redis_expiry = 86400,
-    last_location_timstamp_expiry = 86400,
     location_update_limit = 6000000000,
     location_update_interval = 60,
-    driver_location_update_topic = "location-updates",
     batch_size = 100,
     bucket_size = 30,
     nearby_bucket_threshold = 4,
-    blacklist_merchants = ["favorit0-0000-0000-0000-00000favorit"],
-    request_timeout = 9000,
-    log_unprocessible_req_body = ["UNPROCESSIBLE_REQUEST", "REQUEST_TIMEOUT", "LARGE_PAYLOAD_SIZE", "HITS_LIMIT_EXCEEDED"],
-    max_allowed_req_size = 512000, -- 500 KB
 }
\ No newline at end of file
